#!/usr/bin/perl

=head1 NAME

gpgApplet - GNOME applet for OpenGPG text encryption

=head1 DESCRIPTION

gpgApplet allows encrypting and decrypting the content of the
clipboard with a symmetric cipher using a passphrase. This is
a graphical frontend on top of GnuPG.

Asymmetric decryption and clipboard verification are also supported.

=head1 PREREQUISITES

gpgApplet does not handle passphrase input. Since it also does not
offer terminal interaction unless explicitly run from there, it relies
in practice on some kind of GnuPG agent such as pinentry, Seahorse 2.x
or GNOME keyring 3.x to manage passphrase input.

=cut

use strict;
use warnings;
use 5.10.0;

# VERSION

use Glib qw{TRUE FALSE};
use Gtk2 qw{-init};
use Gtk2::Gdk::Keysyms;
use Gtk2::SimpleList;

use Encode qw{decode encode find_encoding};
use English;
use GnuPG::Interface;
use IO::Handle;
use I18N::Langinfo qw{langinfo CODESET};
use List::MoreUtils qw{none};
use Switch;
use DateTime;

use Locale::gettext;
use POSIX;
setlocale(LC_MESSAGES, "");
textdomain("gpgApplet");


=head1 GLOBALS

=cut

my $codeset       = langinfo(CODESET());
my $encoding      = find_encoding($codeset);
my $main_window   = Gtk2::Window->new();
my $icon_factory  = Gtk2::IconFactory->new();
# Set always_trust since GnuPG otherwise will fail if the key's
# trust hasn't been set.
my %gnupg_options = (armor => 1, always_trust => 1, meta_interactive => 0);

my $pgp_encrypted_msg = {
    type   => 'message',
    header => '-----BEGIN PGP MESSAGE-----',
    footer => '-----END PGP MESSAGE-----'
};
my $pgp_signed_msg = {
    type   => 'signed',
    header => '-----BEGIN PGP SIGNED MESSAGE-----',
    middle => '-----BEGIN PGP SIGNATURE-----',
    footer => '-----END PGP SIGNATURE-----'
};
my @pgp_headers = ($pgp_encrypted_msg, $pgp_signed_msg);

=head1 MAIN

=cut

my $statusicon = build_statusicon();
$statusicon->set_visible(TRUE);
init_freshest_clipboard();
init_icons_stock($icon_factory);
detect_received(freshest_clipboard());
Gtk2->main;


=head1 FUNCTIONS

=cut

sub all_clipboards {
    map {
        Gtk2::Clipboard->get($_)
    } (
        Gtk2::Gdk->SELECTION_CLIPBOARD,
        Gtk2::Gdk->SELECTION_PRIMARY
    );
}

{
    my $freshest_clipboard;

    sub init_freshest_clipboard {
        $freshest_clipboard = Gtk2::Clipboard->get(Gtk2::Gdk->SELECTION_CLIPBOARD);
    }

    sub freshest_clipboard {
        return $freshest_clipboard;
    }

    sub set_freshest_clipboard {
        $freshest_clipboard = shift;
    }
}

sub build_statusicon {
    my $icon = Gtk2::StatusIcon->new;
    $icon->set_visible(FALSE);
    $icon->set_from_icon_name('seahorse');
    $icon->set_tooltip($encoding->decode(gettext('OpenPGP encryption applet')));

    my $menu   = Gtk2::Menu->new;
    my $mexit  = Gtk2::MenuItem->new($encoding->decode(gettext('Exit')));
    $mexit->signal_connect('activate' => sub { Gtk2->main_quit; });
    my $mabout = Gtk2::MenuItem->new($encoding->decode(gettext('About')));
    $mabout->signal_connect('activate' => sub { Gtk2->show_about_dialog(
        $main_window,
        'program-name' => 'gpgApplet',
        'license'      => q{This program is free software; you can redistribute it and/or modify it under the terms of either:

a) the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version, or

b) the "Artistic License" which comes with Perl.
},
        'wrap-license' => 1,
        'website'      => 'https://tails.boum.org/',
    )});
    $menu->append($mexit);
    $menu->append(Gtk2::SeparatorMenuItem->new);
    $menu->append($mabout);

    $icon->signal_connect('popup-menu', sub {
        my $ticon = shift;
        my $event = shift;
        my $time = shift;
        my ($x, $y, $push) = Gtk2::StatusIcon::position_menu($menu, $ticon);
        $menu->show_all;
        $menu->popup(undef, undef, sub {($x, $y,$push)}, undef, $event, $time);
    });

    $icon->signal_connect('button-press-event' => sub {
        my $ticon = shift;
        my $event = shift;
        return unless $event->button == 1;
        my $action_menu = build_action_menu();
        my ($x, $y, $push) = Gtk2::StatusIcon::position_menu($action_menu, $ticon);
        $action_menu->show_all;
        $action_menu->popup(undef, undef, sub {($x, $y,$push)}, undef, $event->button, $event->time);
    });

    foreach (all_clipboards()) {
        $_->signal_connect("owner-change" => sub {
            my $clipboard = shift;
            my $event     = shift;
            handle_clipboard_owner_change($clipboard);
        });
    }

    return $icon;
}

sub build_action_menu {
    my $action_menu = Gtk2::Menu->new;

    my $text_type = detect_text_type(get_validated_clipboard_text());

    if ($text_type eq 'text' or $text_type eq 'none') {
        my $msymencrypt    = Gtk2::MenuItem->new_with_mnemonic($encoding->decode(gettext('Encrypt Clipboard with _Passphrase')));
        $msymencrypt->signal_connect('activate' => sub { operate_on_clipboard(\&symmetric_encrypt, ['text']); });
        $action_menu->append($msymencrypt);
        my $mencrypt    = Gtk2::MenuItem->new_with_mnemonic($encoding->decode(gettext('_Encrypt Clipboard with Public Key')));
        $mencrypt->signal_connect('activate' => sub { operate_on_clipboard(\&encrypt, ['text']); });
        $action_menu->append($mencrypt);
        my $msign    = Gtk2::MenuItem->new_with_mnemonic($encoding->decode(gettext('_Sign Clipboard with Public Key')));
        $msign->signal_connect('activate' => sub { operate_on_clipboard(\&sign, ['text']); });
        $action_menu->append($msign);
        my $msignencrypt    = Gtk2::MenuItem->new_with_mnemonic($encoding->decode(gettext('Sign _and Encrypt Clipboard with Public Key')));
        $msignencrypt->signal_connect('activate' => sub { operate_on_clipboard(\&sign_and_encrypt, ['text']); });
        $action_menu->append($msignencrypt);
    }
    if ($text_type eq 'message' or $text_type eq 'signed') {
        my $mdecryptver = Gtk2::MenuItem->new_with_mnemonic($encoding->decode(gettext('_Decrypt/Verify Clipboard')));
        $mdecryptver->signal_connect('activate' => sub { operate_on_clipboard(\&decrypt_verify, ['message', 'signed']); });
        $action_menu->append($mdecryptver);
    }

    return $action_menu;
}

sub all_text_types {
    map { $_->{type} } @pgp_headers;
}

sub detect_text_type {
    my $text = shift;

    unless (defined $text && length($text)) {
        return 'none';
    }

    foreach (@pgp_headers) {
        my $header = $_->{header};
        my $footer = $_->{footer};
        return $_->{type} if $text =~ m{$header.*$footer}ms;
    }

    return 'text';
}

sub text_is_of_type {
    my $text        = shift;
    my @valid_types = @_;

    my $text_type = detect_text_type($text);
    if (none { $_ eq $text_type } @valid_types) {
        return (
            0,
            $encoding->decode(
                gettext("The clipboard does not contain valid input data."))
        );
    }
    return (1);
}

sub get_validated_clipboard_text {
    my $args = shift;
    my @valid_types;

    if (exists $args->{valid_types} && defined $args->{valid_types}) {
        @valid_types = @{ $args->{valid_types} };
    }
    else {
        @valid_types = all_text_types();
    }

    my $clipboard = freshest_clipboard();
    # Note: according to the GTK documentation, the wait_for_text method
    # is supposed to always returns UTF-8. But it seems like the Perl
    # bindings decode it and we get a string of chars instead of bytes.
    my $content = $clipboard->wait_for_text;
    my ($is_valid, $reason) = text_is_of_type($content, @valid_types);
    return ($content) if $is_valid;
    return (0, $reason);
}

sub set_clipboards_text {
    my $text = shift;
    my $encoded_text = $encoding->encode($text);

    # Note: according to the GTK documentation, the set_text method
    # is supposed to need input encoded in UTF-8. But it seems like the Perl
    # bindings encode it, and we need to pass a string of chars instead of bytes.
    foreach (all_clipboards()) {
        $_->set_text($encoded_text);
    }
    # GTK fails setting the primary selection above, so let's use xclip :/
    open(my $xclip, '| xclip') or die "Error opening pipe to xclip";
    print $xclip $encoded_text or die "Error copying data to X clipboard";
    close $xclip or die "Error closing pipe to xclip";
}

sub explain_validity {
    my $code = shift;
    my $bad = FALSE;
    my $ret;
    # Below taken from doc/DETAILS in GnuPG's sources
    switch ($code) {
        case "o" { $ret = gettext("Unknown Trust"); }
        case "-" { $ret = gettext("Unknown Trust"); }
        case "q" { $ret = gettext("Unknown Trust"); }
        case "i" { $ret = gettext("Invalid Key"); $bad = TRUE; }
        case "r" { $ret = gettext("Revoked Key"); $bad = TRUE; }
        case "e" { $ret = gettext("Expired Key"); $bad = TRUE; }
        case "n" { $ret = gettext("Do not Trust"); $bad = TRUE; }
        case "m" { $ret = gettext("Marginal Trust"); }
        case "f" { $ret = gettext("Full Trust"); }
        case "u" { $ret = gettext("Ultimate Trust"); }
        # Below are some custom flags
        case "F" { $ret = gettext("Fully Valid"); }
        case "E" { $ret = gettext("Cannot Encrypt"); $bad = TRUE; }
        case "S" { $ret = gettext("Cannot Sign"); $bad = TRUE; }
        else     { $ret = $code; }
    }
    return ($bad, $encoding->decode($ret));
}

sub choose_keys {
    my $title  = shift;
    my $secret = shift;
    my @keys   = @_;

    use constant C_NAME          => 0;
    use constant C_KEYID         => 1;
    use constant C_STATUS        => 2;
    use constant C_CREATED       => 3;
    use constant C_EXPIRY        => 4;
    use constant C_STRIKETHROUHG => 5;
    use constant C_FINGERPRINT   => 6;
    use constant C_USERIDS       => 7;

    use constant VISIBLE_COLS => (C_NAME, C_KEYID, C_STATUS, C_CREATED,
                                  C_EXPIRY);
    use constant HIDDEN_COLS => (C_STRIKETHROUHG, C_FINGERPRINT, C_USERIDS);

    my $list = Gtk2::SimpleList->new (
        $encoding->decode(gettext("Name"))    => 'text',
        $encoding->decode(gettext("Key ID"))  => 'text',
        $encoding->decode(gettext("Status"))  => 'text',
        $encoding->decode(gettext("Created")) => 'text',
        $encoding->decode(gettext("Expires")) => 'text',
        "strikethrough?"                      => 'bool',
        "fingerprint"                         => 'text',
        "userids"                             => 'text'
        );
    foreach my $i (VISIBLE_COLS) {
        my $col = $list->get_column($i);
        $col->set_max_width(300);
        $col->set_resizable(TRUE);
        $col->set_sort_column_id($i);
    }
    foreach my $i (HIDDEN_COLS) {
        $list->get_column($i)->set_visible(FALSE);
    }
    my $name_col = $list->get_column(C_NAME);
    foreach my $cell ($name_col->get_cell_renderers()) {
        $name_col->add_attribute ($cell, strikethrough => C_STRIKETHROUHG);
    }
    $list->get_selection->set_mode('multiple') unless $secret;
    $list->get_selection->unselect_all;
    $list->set_has_tooltip(TRUE);
    $list->signal_connect('query-tooltip' => sub {
        my ($wx, $wy, $tooltip) = ($_[1], $_[2], $_[4]);
        my ($x, $y) = $list->convert_widget_to_bin_window_coords($wx, $wy);
        my $path = $list->get_path_at_pos($x, $y);
        return FALSE unless defined $path;
        my $row = ($path->get_indices)[0];
        my $fingerprint =
            join(" ", (${$list->{data}}[$row][C_FINGERPRINT] =~ m/..../g));
        my $text = gettext("User ID(s)") . ":\n" .
                   "${$list->{data}}[$row][C_USERIDS]\n" .
                   gettext("Fingerprint") . ":\n" .
                   "$fingerprint";
        $tooltip->set_text("$text");
        return TRUE;
    });

    foreach my $key (@keys) {
        # If we used Gtk2::TreeView instead of Gtk2::SimpleList we could
        # show all user ids directly in the list, but we make it simple
        # for us and instead show them in the tooltip.
        my $name    = $encoding->decode($key->user_ids->[0]->as_string);
        my $userids = join("\n", map { "- " . $encoding->decode($_->as_string) }
                                     $key->user_ids);
        my $keyid   = $encoding->decode($key->short_hex_id);
        my $bad; # bad keys are listed with strikethrough
        my $status;
        if ($secret) {
            my $code;
            my $expiry = $key->expiration_date;
            if (FALSE) {
                # FIXME: how to detect revoked private keys?
                $code='r';
            } elsif (defined $expiry && DateTime->now->epoch > $expiry) {
                $code='e';
            } elsif (FALSE) {
                # FIXME: how to detect private key without signing capabability?
                $code='S';
            } else {
                $code='F';
            }
            ($bad, $status) = explain_validity($code);
        } else {
            my $validity = $key->user_ids->[0]->validity;
            ($bad, $status) = explain_validity($validity);
            # If the validity doesn't make the key bad the key could still
            # be bad due to lack of encryption capability
            if (!$bad && $key->usage_flags !~ m/E/) {
                ($bad, $status) = explain_validity('E');
            }
        }
        my $fingerprint = $encoding->decode($key->fingerprint->as_hex_string());
        my $created     = $encoding->decode($key->creation_date_string);
        my $expiry_str  = $key->expiration_date_string;
        if (defined $expiry_str) {
            $expiry_str = $encoding->decode($expiry_str);
        } else {
            $expiry_str = $encoding->decode(gettext("Never"));
        }
        push(@{$list->{data}}, [$encoding->encode($name),
                                $encoding->encode($keyid),
                                $encoding->encode($status),
                                $encoding->encode($created),
                                $encoding->encode($expiry_str),
                                $bad,
                                $encoding->encode($fingerprint),
                                $encoding->encode($userids)]);
    }

    my $scroll = Gtk2::ScrolledWindow->new;
    $scroll->set_policy('automatic', 'automatic');
    $scroll->add($list);

    my $dialog = Gtk2::Dialog->new($title, $main_window, 'destroy-with-parent',
                                   'gtk-cancel' => 'cancel', 'gtk-ok' => 'ok' );
    $dialog->set_default_size(700,500);
    $dialog->set_default_response('ok');
    $dialog->vbox->add($scroll);
    my @selection;
    $dialog->signal_connect(response => sub {@selection = $list->get_selected_indices;});
    $list->signal_connect('key-press-event' => sub {
        my $event = $_[1];
        return unless $event->keyval == $Gtk2::Gdk::Keysyms{Return};
        $dialog->response('ok');
        return 1;
    });
    $list->signal_connect('row-activated' => sub { $dialog->response('ok'); });
    $scroll->show;
    $list->show;
    $list->select(0);
    $list->grab_focus;
    my $ans = $dialog->run;
    $dialog->destroy;
    if ('ok' eq $ans) {
        if (@selection) {
            return map { $list->{data}[$_][C_FINGERPRINT] } @selection;
        } else {
            display_error($encoding->decode(gettext("No keys selected")),
                          $encoding->decode(gettext(
                              "You must select at least one key."
                                           )));
            return choose_keys($title, $secret, @keys);
        }
    } else {
        return ();
    }
}

sub set_recipients {
    my $gnupg = shift;

    my @keys = $gnupg->get_public_keys();
    if (@keys == 0) {
        display_error($encoding->decode(gettext("No public keys available")),
                      $encoding->decode(gettext(
                          "You need public keys to be able to encrypt messages."
                                       )));
        return 0;
    }

    my @recipients = choose_keys($encoding->decode(gettext(
                                     "Choose recipient keys"
                                                  )), FALSE, @keys);

    return 0 unless @recipients;

    $gnupg->options->clear_recipients();
    $gnupg->options->push_recipients(@recipients);
    return 1;
}

sub set_signer {
    my $gnupg = shift;

    my @keys = $gnupg->get_secret_keys();
    my @signer;

    if (@keys == 0) {
        display_error($encoding->decode(gettext("No private key available")),
                      $encoding->decode(gettext(
                          "You need a private key to be able to sign messages."
                                       )));
        return 0;
    } elsif (@keys == 1) {
        @signer = $keys[0]->short_hex_id;
    }
    else {
        @signer = choose_keys($encoding->decode(gettext("Choose signing key")),
                              TRUE, @keys);
        return 0 unless @signer;
    }

    $gnupg->options->meta_signing_key_id(@signer);
    return 1;
}

sub encrypt {
    my $args    = shift;
    my $gnupg   = $args->{gnupg};
    my $handles = $args->{handles};

    return 0 unless set_recipients($gnupg);

    return $gnupg->encrypt(handles => $handles);
}

sub sign {
    my $args    = shift;
    my $gnupg   = $args->{gnupg};
    my $handles = $args->{handles};

    return 0 unless set_signer($gnupg);

    return $gnupg->clearsign(handles => $handles);
}

sub sign_and_encrypt {
    my $args    = shift;
    my $gnupg   = $args->{gnupg};
    my $handles = $args->{handles};

    return 0 unless (set_signer($gnupg) && set_recipients($gnupg));

    return $gnupg->sign_and_encrypt(handles => $handles);
}

sub symmetric_encrypt {
    my $args    = shift;
    my $gnupg   = $args->{gnupg};
    my $handles = $args->{handles};

    return $gnupg->encrypt_symmetrically(handles => $handles);
}

sub decrypt_verify {
    my $args    = shift;
    my $gnupg   = $args->{gnupg};
    my $handles = $args->{handles};
    my $input   = $args->{input};

    my $text_type = detect_text_type($input);
    return
        $text_type eq 'message'
      ? $gnupg->decrypt(handles => $handles)
      : $gnupg->verify(handles => $handles);
}

sub gpg_operate_on_text {
    my $operation = shift;
    my $text      = shift;

    my $gnupg = GnuPG::Interface->new();
    $gnupg->options->hash_init(%gnupg_options);
    my $in_h    = IO::Handle->new();
    my $err_h   = IO::Handle->new();
    my $out_h   = IO::Handle->new();
    my $handles = GnuPG::Handles->new(
        stdin => $in_h,
        stderr => $err_h,
        stdout => $out_h
    );

    my $args = {
        gnupg   => $gnupg,
        handles => $handles,
        input   => $text,
        in_h    => $in_h,
        err_h   => $err_h,
        out_h   => $out_h,
    };

    my $pid = $operation->($args) or return;

    # We assume the sender/recipient uses the same charset as us :/
    # PGP/MIME was invented for a reason.
    print $in_h $encoding->encode($text);
    close $in_h;

    my ($err, $out) = read_err_out($err_h, $out_h);
    my @raw_stderr = @{$err};
    my @raw_stdout = @{$out};

    waitpid $pid, 0; # Clean up the finished GnuPG process.

    my $std_err = $encoding->decode(join('', @raw_stderr));
    my $std_out = $encoding->decode(join('', @raw_stdout));

    if ($CHILD_ERROR == 0) {
        if ($operation eq \&decrypt_verify) {
            my $msg;
            if ($text =~ m/$pgp_signed_msg->{header}/) {
                $msg = $text;
                $msg =~ s/^.*$pgp_signed_msg->{header}\nHash: [^\n]*\n\n//m;
                $msg =~ s/^$pgp_signed_msg->{middle}.*//ms;
            } else {
                $msg = $std_out;
            }
            display_output($msg, $std_err);
        } else {
            set_clipboards_text($std_out);
        }
    }
    else {
        display_error(
            $encoding->decode(gettext("GnuPG error")),
            $std_out . "\n\n" . $std_err
        );
        return;
    }

    return;
}

sub operate_on_clipboard {
    my $operation   = shift;
    my $valid_types = shift;

    my ($text, $clip_error) = get_validated_clipboard_text(
        { valid_types => $valid_types }
    );

    if (defined $clip_error) {
        display_error(
            $clip_error, # already translated and decoded
            $encoding->decode(gettext("Therefore the operation cannot be " .
                                      "performed."))
        );
        return;
    }

    gpg_operate_on_text($operation, $text);
}

sub display_error {
    my $title = shift;
    my $msg   = shift;

    my $dialog = Gtk2::MessageDialog->new(
        $main_window, 'destroy-with-parent', 'error', 'ok',
        $title
    );
    $dialog->format_secondary_text($msg);
    $dialog->signal_connect(
        response => sub { my $self = shift; $self->destroy; }
    );
    $dialog->set_position('center');
    $dialog->run;
    $dialog->destroy;

    return 1;
}

# FIXME: let window grow depending on output text size
sub display_output {
    my $std_out = shift;
    my $std_err = shift;

    my $dialog = Gtk2::MessageDialog->new(
        $main_window, 'destroy-with-parent', 'info', 'ok',
        $encoding->decode(gettext("GnuPG results"))
    );
    my $my_width_request = 800;
    my $my_height_request = 600;
    # TRANSLATORS: GnuPG stdout (encrypted or decrypted message)
    $dialog->format_secondary_text(sprintf($encoding->decode(gettext(
        "Here is the GnuPG output:"
    ))));

    my $msg_area = $dialog->get_content_area;

    my $outbuf = Gtk2::TextBuffer->new();
    $outbuf->set_text($std_out);
    my $text_desc = Pango::FontDescription->new;
    $text_desc->set_family('Monospace');
    my $textview_out = Gtk2::TextView->new_with_buffer($outbuf);
    $textview_out->set_editable(FALSE);
    $textview_out->set_cursor_visible(FALSE);
    $textview_out->set_left_margin(10);
    $textview_out->set_right_margin(10);
    $textview_out->set_wrap_mode('word');
    $textview_out->modify_font($text_desc);
    my $scrolled_win_out = Gtk2::ScrolledWindow->new;
    $scrolled_win_out->set_policy('automatic', 'automatic');
    $scrolled_win_out->add($textview_out);
    $msg_area->pack_start($scrolled_win_out, TRUE, TRUE, 0);

    if (defined $std_err && length($std_err)) {
        my $std_err_title = Gtk2::Label->new(
            # TRANSLATORS: GnuPG stderr (other informational messages)
            $encoding->decode(gettext(
                "While it were at it, GnuPG also mentionned in passing:"
            )));
        $std_err_title->set_alignment(0, 0);
        $std_err_title->set_padding(10, 0);
        $msg_area->pack_start($std_err_title, FALSE, FALSE, 0);
        my $std_err_text = Gtk2::Label->new($std_err);
        $std_err_text->modify_font($text_desc);
        $std_err_text->set_alignment(0, 0);
        $std_err_text->set_padding(10, 0);
        $msg_area->pack_start($std_err_text, FALSE, FALSE, 0);
    }

    $dialog->signal_connect(
        response => sub { my $self = shift; $self->destroy; }
    );
    my $screen_width = $dialog->get_screen()->get_width();
    my $screen_height = $dialog->get_screen()->get_height();
    if ($screen_width > $my_width_request || $screen_height > $my_height_request) {
        $dialog->set_size_request($my_width_request, $my_height_request);
    } else {
        $dialog->maximize();
    }
    $dialog->set_resizable(TRUE);
    $dialog->set_position('center');
    $dialog->show_all;

    return 1;
}

# Read stdout and stderr at the same time, one line at a time, to
# avoid dead-locking due to one of the buffers being full.
sub read_err_out {
    my $err_h = shift;
    my $out_h = shift;

    my $err   = [];
    my $out   = [];

    while (1) {
        my $err_l = <$err_h>;
        my $out_l = <$out_h>;
        push @{$err}, $err_l if defined $err_l;
        push @{$out}, $out_l if defined $out_l;
        last unless ($err_l || $out_l);
    }
    close $err_h;
    close $out_h;

    return ($err, $out);
}

sub update_icon {
    my $text_type = shift;

    $statusicon->set_from_stock("gpgApplet-${text_type}");
}

sub detect_received {
    my $clipboard = shift;

    update_icon(detect_text_type(get_validated_clipboard_text()));
}

sub handle_clipboard_owner_change {
    my $clipboard = shift;

    set_freshest_clipboard($clipboard);
    detect_received($clipboard);
}

sub make_icon_source {
    my $icon = shift;
    my $base = shift;
    my $ext  = shift;
    my $size = shift;

    my $filename = "/usr/share/pixmaps/gpgApplet/$base/$icon.$ext";
    my $source = Gtk2::IconSource->new();
    $source->set_filename($filename);
    $source->set_direction_wildcarded(1);
    $source->set_state_wildcarded(1);
    if (defined $size) {
        $source->set_size_wildcarded(0);
        $source->set_size($size);
    } else {
        $source->set_size_wildcarded(1);
    }

    return $source;
}

sub init_icons_stock {
    my $factory = shift;

    $factory->add_default;
    my @stock_ids = map { "gpgApplet-$_" } qw{ message none signed text };

    foreach my $stock_id (@stock_ids) {
        my $iconset = Gtk2::IconSet->new();
        $iconset->add_source(make_icon_source($stock_id, "22x22",    "png", 'button'));
        $iconset->add_source(make_icon_source($stock_id, "22x22",    "png", 'menu'));
        $iconset->add_source(make_icon_source($stock_id, "22x22",    "png", 'large-toolbar'));
        $iconset->add_source(make_icon_source($stock_id, "22x22",    "png", 'small-toolbar'));
        $iconset->add_source(make_icon_source($stock_id, "48x48",    "png", 'dialog'));
        $iconset->add_source(make_icon_source($stock_id, "scalable", "svg"));
        $factory->add($stock_id, $iconset);
    }
}
