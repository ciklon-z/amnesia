Instead of cluttering our main Git repository with Debian source and
binary packages, we'd better setup an APT repository for our custom
packages.

[[!toc levels=2]]

Overview
========

We use one single APT repository hosting multiple *suites*:

* We have a (read-only) suite for every past release: `0.9`,
  `0.10.1`, etc.
* We have a suite for each *main* branch: `stable`, `testing`, `devel`
* We have a suite for each *topic* branch: `bugfix/*`, `feature/*`.
  **Important note**: the APT suite corresponding to a given Git topic
  branch contains *only* the packages this branch adds to the tag or
  *main* branch it diverged from.
* We also have a less formal `unstable` suite, that should not be used
  by any Tails git branch; it can be used as hosting space for other
  packaging work we might do, e.g. acting as upstream or
  Debian maintainers.

The suite(s) to use as sources for APT, during the build and inside
the resulting system, are determined at Tails build time
(`auto/config`). See details in the *Build system* section bellow.

We manage our APT repository with
[reprepro](http://mirrorer.alioth.debian.org/).

The Puppet modules used to manage this part of our infrastructure are
listed on our [[contribute/Git]] page.

Private side
============

Manage an APT repository using reprepro. Allow importing packages,
creating new suites, merging, freezing, etc.

Left to do
----------

[[!tag todo/code todo/sysadmin]]

* Allow importing packages, creating new suites, merging, freezing,
  etc.; see the *Documentation* section bellow.
  - reprepro's incoming directory: whatever ACL and umask I set,
    dupload with scp backend, connecting to a non-reprepro user on the
    APT repo box, puts files in there that are not writable by the
    reprepro user, so `reprepro processincoming` fails. In the
    meantime, we upload to `reprepro@incoming.t.b.o`, but it would
    be a bit nicer to deal with that in a better way, some day.
* test basic operations to check that suite are in the supported set:
  - tails-merge-suite sid -> 0.11 -- **??** (`tails-merge-suite`
    should maybe prevent us from doing that, as 0.11 was released
    already; however, we do need to do this copy to build the 0.11
    ISO, so a --force switch would have to be provided)
  - tails-merge-suite branch with long/complicated name -> devel **OK**
  - tails-merge-suite sid -> devel -- **OK**
  - tails-merge-suite sid -> doc-donate -- **OK**
  - tails-merge-suite sid -> bugfix-boot-profile-vs-live-rofs -- **OK**
  - list suite with long/complicated name **OK**
  - manually import a package into branch with long/complicated name **OK**
  - let inotincoming import a package into branch with long/complicated name **OK**
* import binary and source packages from our Git repository:
  - currently used branches
  - past releases... at least the most recent ones, depending on how
    much pain it takes to do it.
* tell reprepro to email what `processincoming` does: <file:///usr/share/doc/reprepro/manual.html#hooks>
* host our `tails_secrets_apt` Puppet module's Git repository on
  lizard

Done
----

* reprepro initial setup
* scan the Tails Git repository on a regular basis, detect new bugfix
  or feature branches, and accordingly:
  - generate `conf/distributions`
  - generate `conf/incoming`
  - generate `conf/pulls`
  - create new suites in the APT repository

HTTP access
===========

This is the http:// public APT repository that will be used at Tails
build time.

Left to do
----------

[[!tag todo/sysadmin]]

* setup HTTP access to this APT repository

Build system
============

The build system must add the relevant APT sources:

* if the version in `debian/changelog` was released already (i.e.
  a matching tag exists), then add the suite corresponding to this
  release (e.g. `0.10` or `0.10.1`);
* else, if building from the `testing` branch, add the `testing` suite
* else, if building from the `devel` branch, add its own suite

Also, if we're building from a bugfix or feature branch, add its
own suite.

This logic was implemented and integrated into our build system
(`feature/apt-repository` branch).

Workflow
========

[[!tag todo/documentation todo/code]]

Design and document the actions, possibly write helper scripts, needed
when...

Importing a new package
-----------------------

### Building a package

Make sure the `Distribution:` field in your `.changes` file matches
the suite you want the package to land in (e.g.
pass `--changes-option=-DDistribution=feature-torbrowser` to
pdebuild's `--debbuildopts`).

Make sure to have the `.changes` file include the original source
archive (`.orig.tar.{gz,bz2,xz}`) if it is not already in our APT
repository; this can be done by passing `-sa` to pdebuild's
`--debbuildopts`.

### Configuring dupload

Add this configuration snippet to your `dupload` configuration:

	$config::cfg{'tails'} = {
	        fqdn => "incoming.deb.tails.boum.org",
	        method => "scp",
	        login => "reprepro",
	        incoming => "/srv/reprepro/incoming/",
	        dinstall_runs => 1,
	};

(`dput` lovers, please contribute your own snippet.)

### Uploading and importing process

Carefully prepare and build your package. Usual precautions, (Lintian
etc.) apply.

Carefully check the `.changes` file (especially the `Distribution`
control field, and the included files list).

Sign the `.changes` file with a key that is in the uploaders list:

	$ debsign $CHANGES_FILE

Upload the files to the incoming queue:

	$ dupload --to tails $CHANGES_FILE

reprepro will automatically notice the new files and import them into
the suite specified in your `.changes` file.

Check the result:

	$ reprepro list $SUITE $PACKAGENAME

Merging a topic branch
----------------------

When a Git *topic* branch is merged into a *main* branch, the
corresponding similar operation must be done on the APT suites.

Example:

	$ git checkout devel
	$ git merge feature/icedove
	$ ssh reprepro@incoming.deb.tails.boum.org \
	     tails-merge-suite feature/icedove devel
	$ git push

**FIXME**: I think I had to `retrack` after importing a package, who
knows why, so that `reprepro dumptracks` (called by
`tails-merge-suite`) outputs anything and the suite merge process
works. Should be retried and fixed. [[!tag todo/sysadmin]]

Note that unfortunately, contrary to what whoever with a Git
background would guess, the reprepro operation called *pull* is not
what we want: it pulls from *all* other suites into the ones specified
on the command-line.

Freezing devel into testing
---------------------------

1. Merge `devel` branch into `testing` in Git
2. Either merge the `devel` APT suite into the `testing` one, **or**
   hard reset `testing` suite to the current state of the `devel`
   suite? (If the latter: how? delete with `removematched codename
   glob` and then copy? -- beware:  do the `*matched` commands act on
   source + binary?)

Releasing a point-release
-------------------------

(from the stable branch)

tag in Git, fork `stable` APT suite into `$NEW_VERSION`.

Releasing a major release
-------------------------

(from the testing branch)

tag in Git, fork `testing` APT suite into `$NEW_VERSION`

Post-release
------------

After merging stable or testing into devel, e.g. increment the version
number in devel's `debian/changelog`.

Giving access to a core developer
---------------------------------

1. Give SSH access to the `reprepro` user on the system that hosts
   reprepro (using the `ssh_authorized_key` Puppet resource).
2. Import the developer's public GnuPG key into the `reprepro` user's
   GnuPG keyring -- should be doable using Puppet, some day
   [[!tag todo/sysadmin]]
3. Add the developer's OpenPGP key ID to `$reprepro_uploaders` in our
   `tails::reprepro` Puppet module. Deploy.

Contributing without privileged access
--------------------------------------

Non-core developer without access to the "private" APT infrastructure:
they would add the .deb they want to their Git branch as we have been
doing until now, push the result on repo.or.cz or whatever... and at
merge time, we would rewrite their history to remove the .deb, and
import it into our APT repo.


[[!tag broken_window]]
