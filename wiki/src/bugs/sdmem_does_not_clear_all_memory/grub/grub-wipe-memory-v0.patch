--- grub-2.00.orig/grub-core/Makefile.core.def	2012-06-26 04:13:58.000000000 +0200
+++ grub-2.00/grub-core/Makefile.core.def	2012-08-19 00:38:23.254479691 +0200
@@ -726,6 +726,11 @@
 };
 
 module = {
+  name = wipe_memory;
+  common = commands/wipe_memory.c;
+};
+
+module = {
   name = lspci;
   common = commands/lspci.c;
 
--- grub-2.00.orig/grub-core/commands/wipe_memory.c	1970-01-01 01:00:00.000000000 +0100
+++ grub-2.00/grub-core/commands/wipe_memory.c	2012-08-26 12:00:51.198571883 +0200
@@ -0,0 +1,319 @@
+/*
+ *  GRUB  --  GRand Unified Bootloader
+ *  Copyright (C) 2008  Free Software Foundation, Inc.
+ *
+ *  GRUB is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  GRUB is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with GRUB.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include <grub/dl.h>
+#include <grub/misc.h>
+#include <grub/command.h>
+#include <grub/i18n.h>
+#include <grub/memory.h>
+#include <grub/i386/memory.h>
+#include <grub/mm.h>
+
+GRUB_MOD_LICENSE ("GPLv3+");
+
+#define LOWER_MEMORY_LIMIT 0xffffffff
+#define BUFFER_LEN 0x0010000
+
+static grub_err_t
+grub_wipe_with_malloc (void)
+
+{
+  void * ptrs[LOWER_MEMORY_LIMIT / BUFFER_LEN];
+  grub_uint16_t i = 0;
+
+  grub_printf ("Start GB memory wipe below 4G...\n");
+
+  /* Start by wiping GRUB heap using malloc. */
+  while (NULL != (ptrs[i++] = grub_zalloc (BUFFER_LEN)))
+    {
+      if (0 == (i % 256))
+        grub_printf ("*");
+    }
+  grub_printf ("\n");
+
+  grub_printf ("Wiped: %08x (%u)\n", i * BUFFER_LEN, i);
+
+  /* Getting out of memory is expected. */
+  grub_errno = GRUB_ERR_NONE;
+
+  /* Let's free our previous buffers. */
+  do
+    {
+      grub_free (ptrs[i]);
+    } while (--i > 0);
+
+  grub_printf ("i: %u\n", i);
+
+  return GRUB_ERR_NONE;
+}
+
+#define PG_V             0x001
+#define PG_RW            0x002
+#define PG_U             0x004
+#define PG_PS            0x080
+#define PG_G             0x200
+
+#define PDPT_SIZE        4
+#define PAGE_DIR_SIZE    512
+#define PAGE_SIZE        (2 * 1024 * 1024) /* 2 MB */
+
+#define CLEANUP_REGION_START 0x80000000 /* 2 GB */
+#define CLEANUP_REGION_SIZE (16 * PAGE_SIZE) /* 32 MB */
+#define CLEANUP_REGION_END  (CLEANUP_REGION_START + CLEANUP_REGION_SIZE - 1)
+
+#define GRUB_MEMORY_CPU_CR4_PGE_ON		0x00000080
+
+#define ENABLE_PAE \
+  asm volatile (" \
+      movl    %%cr4, %%eax; \
+      orl     %0, %%eax; \
+      movl    %%eax, %%cr4; \
+    " : : "i" (GRUB_MEMORY_CPU_CR4_PAE_ON | GRUB_MEMORY_CPU_CR4_PGE_ON) );
+
+#define DISABLE_PAE \
+  asm volatile (" \
+      movl    %%cr4, %%eax; \
+      andl    %0, %%eax; \
+      movl    %%eax, %%cr4; \
+    " : : "i" (~(GRUB_MEMORY_CPU_CR4_PAE_ON | GRUB_MEMORY_CPU_CR4_PGE_ON)) );
+
+#define ENABLE_PAGING \
+  asm volatile (" \
+      movl    %%cr0, %%eax; \
+      orl     %0, %%eax; \
+      movl    %%eax, %%cr0; \
+    " : : "i" (GRUB_MEMORY_CPU_CR0_PAGING_ON) );
+
+#define DISABLE_PAGING \
+  asm volatile (" \
+      movl    %%cr0, %%eax; \
+      andl    %0, %%eax; \
+      movl    %%eax, %%cr0; \
+    " : : "i" (~GRUB_MEMORY_CPU_CR0_PAGING_ON) );
+
+#define UPDATE_PAGE_DESCRIPTORS \
+  asm volatile (" \
+      movl    %%eax, %%cr3; \
+    " : : "a" (&page_dir_ptr_tab[0]));
+
+static grub_uint64_t page_dir_ptr_tab[PDPT_SIZE] __attribute__ ((aligned (0x20)));
+static grub_uint64_t page_dir[4 * PAGE_DIR_SIZE] __attribute__ ((aligned (0x1000)));
+static grub_uint64_t * page_dir_cleanup = &page_dir[CLEANUP_REGION_START / 512];
+
+static grub_err_t
+grub_map_cleanup (grub_uint64_t start)
+{
+  unsigned short i;
+
+  for (i = 0; i * PAGE_SIZE < CLEANUP_REGION_SIZE; i++)
+    {
+      page_dir_cleanup[i] = start + i * PAGE_SIZE;
+      page_dir_cleanup[i] |= PG_V | PG_RW | PG_U | PG_PS;
+      grub_printf ("page_dir_cleanup[%u]: %08llx\n", i, page_dir_cleanup[i]);
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_init_page_directories (void)
+{
+  unsigned short i;
+
+  grub_memset (page_dir_ptr_tab, 0, PDPT_SIZE * sizeof (grub_uint64_t));
+
+  /* Map everything to the same physical location. */
+  for (i = 0; i < 4; i++)
+    {
+      page_dir_ptr_tab[i] = (grub_uint64_t) (grub_addr_t) &page_dir[i * PAGE_DIR_SIZE];
+      page_dir_ptr_tab[i] |= PG_V;
+    }
+  for (i = 0; i < 4 * PAGE_DIR_SIZE; i++)
+    {
+      page_dir[i] = i * PAGE_SIZE;
+      /* Set pages not used for cleanup as global. */
+      if (page_dir[i] >= CLEANUP_REGION_START && page_dir[i] <= CLEANUP_REGION_END)
+        page_dir[i] |= PG_G;
+      page_dir[i] |= PG_V | PG_RW | PG_U | PG_PS;
+    }
+
+  return GRUB_ERR_NONE;
+}
+
+struct region_s
+{
+  grub_uint64_t addr;
+  grub_uint64_t size;
+};
+
+#define MAX_REGIONS 16
+
+static grub_err_t
+grub_find_high_order_regions (struct region_s * regions)
+{
+  unsigned short i = 0;
+
+  auto int NESTED_FUNC_ATTR hook (grub_uint64_t, grub_uint64_t, grub_memory_type_t);
+  int NESTED_FUNC_ATTR hook (grub_uint64_t addr, grub_uint64_t size,
+                             grub_memory_type_t type)
+    {
+      if (MAX_REGIONS == i)
+        return 0;
+
+      if (GRUB_MEMORY_AVAILABLE != type)
+        return 0;
+
+      /* Skip the lower regions */
+      if (addr < LOWER_MEMORY_LIMIT)
+        return 0;
+
+      regions[i].addr = addr;
+      regions[i].size = size;
+      i++;
+
+      return 0;
+    }
+  grub_machine_mmap_iterate (hook);
+
+  if (i >= MAX_REGIONS)
+    goto no_mem;
+
+  return GRUB_ERR_NONE;
+
+no_mem:
+  grub_error (GRUB_ERR_OUT_OF_MEMORY, N_("out of memory"));
+  return 0;
+}
+
+static grub_err_t
+grub_wipe_regions (struct region_s * regions)
+{
+  unsigned short i;
+  grub_uint64_t addr;
+  grub_uint64_t size;
+  grub_addr_t current;
+
+  for (i = 0; regions[i].size > 0 && i < MAX_REGIONS; i++)
+    {
+      addr = regions[i].addr;
+      size = regions[i].size;
+
+      grub_printf ("zero'ing addr = 0x%" PRIxGRUB_UINT64_T ", length = 0x%" PRIxGRUB_UINT64_T "\n",
+                   (grub_uint64_t) addr, (grub_uint64_t) size);
+
+      while (0 < size)
+        {
+          grub_map_cleanup (addr);
+          UPDATE_PAGE_DESCRIPTORS;
+
+          current = (grub_addr_t) CLEANUP_REGION_START;
+          grub_printf ("current %p\n", (void *) current);
+          while (0 < size && current >= CLEANUP_REGION_START && current <= CLEANUP_REGION_END)
+            {
+              if (0 == (current & 0xffffff))
+                grub_printf("wipe 0x%016" PRIxGRUB_UINT64_T " mapped at 0x%08" PRIxGRUB_ADDR "\n", (grub_uint64_t) addr - CLEANUP_REGION_START + current, current);
+
+              /* *((grub_uint32_t *) current) = 0; */
+              current += sizeof (grub_uint32_t);
+              size -= sizeof (grub_uint32_t);
+            }
+          addr += CLEANUP_REGION_SIZE;
+        }
+    }
+  /* Leave things as we found them. */
+  grub_map_cleanup (CLEANUP_REGION_START);
+  UPDATE_PAGE_DESCRIPTORS;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_wipe_high_order (void)
+{
+  struct region_s regions[MAX_REGIONS];
+
+  grub_printf ("wipe_high_order\n");
+
+  grub_memset(regions, 0, MAX_REGIONS * sizeof (struct region_s));
+  grub_find_high_order_regions(regions);
+  {
+    unsigned short i = 0;
+    for (i = 0; i < MAX_REGIONS; i++)
+      grub_printf ("regions[%u] %016" PRIxGRUB_UINT64_T ", %016" PRIxGRUB_UINT64_T "\n", i, regions[i].addr, regions[i].size);
+  }
+
+  if (0 == regions[0].size)
+    return GRUB_ERR_NONE;
+
+  grub_printf ("init page directories\n");
+  grub_init_page_directories ();
+  grub_printf ("disable paging\n");
+  DISABLE_PAGING;
+  grub_printf ("enable pae\n");
+  ENABLE_PAE;
+  grub_printf ("page_dir_ptr_table: %p\n", page_dir_ptr_tab);
+  grub_printf ("page_dir_ptr_table[0]: %08llx\n", page_dir_ptr_tab[0]);
+  grub_printf ("page_dir_ptr_table[1]: %08llx\n", page_dir_ptr_tab[1]);
+  grub_printf ("page_dir[0]: %08llx\n", page_dir[0]);
+  grub_printf ("page_dir[1]: %08llx\n", page_dir[1]);
+  grub_printf ("page_dir_cleanup[0]: %08llx\n", page_dir_cleanup[0]);
+  grub_printf ("update page descriptors\n");
+  UPDATE_PAGE_DESCRIPTORS;
+  grub_printf ("enable paging\n");
+  ENABLE_PAGING;
+  grub_printf ("go\n");
+
+  grub_wipe_regions (regions);
+
+  grub_printf ("done.\n");
+
+  DISABLE_PAGING;
+  DISABLE_PAE;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_err_t
+grub_cmd_wipe_memory (grub_command_t cmd __attribute__ ((unused)),
+                      int argc __attribute__ ((unused)),
+                      char **args __attribute__ ((unused)))
+
+{
+  grub_err_t err;
+
+  if (GRUB_ERR_NONE != (err = grub_wipe_high_order ()))
+    return err;
+
+  if (GRUB_ERR_NONE != (err = grub_wipe_with_malloc ()))
+    return err;
+
+  return GRUB_ERR_NONE;
+}
+
+static grub_command_t cmd;
+
+GRUB_MOD_INIT(wipe_memory)
+{
+  cmd = grub_register_command ("wipe_memory", grub_cmd_wipe_memory,
+                               0, N_("Fill all available memory with zeros."));
+}
+
+GRUB_MOD_FINI(wipe_memory)
+{
+  grub_unregister_command (cmd);
+}
